{
    "title": "Multi-module Log rotation in Windows",
    "author": "GoatRocketeer",
    "subreddit": "learnpython",
    "rank": 15,
    "score": 1,
    "upvote_ratio": 1.0,
    "num_comments (reported by reddit)": 2,
    "url": "https://www.reddit.com/r/learnpython/comments/1jejges/multimodule_log_rotation_in_windows/",
    "id": "1jejges",
    "selftext": "I have a python script running on a windows machine which utilizes the logging module for logging.\n\nI have multiple modules in my python script. For readability I want the log lines to contain what module they came from. As far as I know, this means I need a distinct instantiation of the Logger class per module, which means multiple fileHandlers are open on the same file.\n\nSo in each module, I have the following:\n\n    ...\n    import MyLogger\n    ...\n    logger = MyLogger.getLogger(__name__)\n    ...\n\nAnd then in the \"MyLogger\" module, \"getLogger()\" is defined as:\n\n    globalPrevTime = None\n    \n    def getLogger(name):\n        logger = logging.getLogger(name)\n    \n        # If this logger has not been setup yet\n        if not logger.handlers:\n            logger.setLevel(logging.INFO)\n            \n            # Sets the log file format\n            formatter = logging.Formatter(fmt='[%(asctime)s] %(levelname)-8s %(name)-15s  %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n    \n            # Set the formatter for the file\n            global globalPrevTime\n            if globalPrevTime is None:\n                globalPrevTime = time.time()\n            filename = \"logs/\" + datetime.fromtimestamp(globalPrevTime).strftime('myLog_%Y-%m-%d_%H-%M.log')  \n            fileHandler = logging.FileHandler(filename)\n            fileHandler.setFormatter(formatter)\n            logger.addHandler(fileHandler)\n                    \n            # Also print to stdout\n            stdoutHandler = logging.StreamHandler(stream=sys.stdout)\n            stdoutHandler.setFormatter(formatter)\n            logger.addHandler(stdoutHandler)\n\nSo far so good.\n\nMy script can run for a long time, so I would like to add log rotation. However, Windows is unable to rename the old log file because its open in multiple fileHandlers:\n\n    PermissionError: [WinError 32] The process cannot access the file because it is being used by another process\n\nI figured I could circumvent this issue by not renaming the log file while rotating it out - instead, when the time comes to rotate, I just make a new log file with a different name and write into that one. I thought I could implement this by declaring a custom Logger class which inherits from logging.Logger, but then I realized I don't have control over the Logger that gets constructed because we allocate new loggers via static method logging.getLogger().\n\nI came up with the solution of overriding the existing logging.Logger.\\_log method to do what I want it to:\n\n    import logging\n    from datetime import datetime\n    import sys\n    import time\n    \n    globalPrevTime = None\n    \n    # New _log method which \"rotates\" the log file every 24 hours\n    # Unlike regular rotation, it doesn't rename the old log file, it just creates a new one.\n    # This dodges the windows \"rename file which is open in multiple file handlers\" issue.\n    def _customLog(self, level, msg, args, exc_info=None, extra=None, stack_info=False, stacklevel=1):\n        # Check if a set amount of time has passed since the log file was created:\n        currTime = time.time()\n        if currTime - self.myPrevTime > 86400:\n            global globalPrevTime\n            # If this is the first _log call in the new time period, create a new log file\n            if self.myPrevTime == globalPrevTime:\n                globalPrevTime = currTime\n            self.removeHandler(self.myFileHandler)\n            self.myPrevTime = globalPrevTime\n            filename = \"logs/\" + datetime.fromtimestamp(globalPrevTime).strftime('myLog_%Y-%m-%d_%H-%M.log')\n            newFileHandler = logging.FileHandler(filename)\n            newFileHandler.setFormatter(self.myFormatter)\n            self.addHandler(newFileHandler)\n            self.myFileHandler = newFileHandler\n            \n        return self._originalLog(level, msg, args, exc_info, extra, stack_info, stacklevel)\n    \n    # Modifying _log at runtime. Insanely suspect\n    logging.Logger._originalLog = logging.Logger._log\n    logging.Logger._log = _customLog\n    \n    def getLogger(name):\n        logger = logging.getLogger(name)\n    \n        # If this logger has not been setup yet\n        if not logger.handlers:\n            logger.setLevel(logging.INFO)\n            \n            # Sets the log file format\n            formatter = logging.Formatter(fmt='[%(asctime)s] %(levelname)-8s %(name)-15s  %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n    \n            # Set the formatter for the file\n            global globalPrevTime\n            if globalPrevTime is None:\n                globalPrevTime = time.time()\n            filename = \"logs/\" + datetime.fromtimestamp(globalPrevTime).strftime('myLog_%Y-%m-%d_%H-%M.log')  \n            fileHandler = logging.FileHandler(filename)\n            fileHandler.setFormatter(formatter)\n            logger.addHandler(fileHandler)\n            \n            # Save member variables to the logger object so that the file \"rotator\" works:\n            logger.myPrevTime = globalPrevTime\n            logger.myFormatter = formatter\n            logger.myFileHandler = fileHandler\n            \n            # Also print to stdout\n            stdoutHandler = logging.StreamHandler(stream=sys.stdout)\n            stdoutHandler.setFormatter(formatter)\n            logger.addHandler(stdoutHandler)\n            \n        return logger\n\n...but of course this has left me extremely uneasy as the various stack overflow articles instructing me on how to do this described the technique with colorful phrases such as \"shooting your own grandmother\" and \"whoever uses your code will for sure want to kill you\". The reasoning is not lost on me: \"\\_log\" is not part of the public API and thus likely does something besides what I think it does and is subject to change at any notice.\n\nSurely others have run into this problem. How should I be logging in a python script on a window's machine such that the name of the calling module is included in the log line?",
    "comments": [
        {
            "author": "Diapolo10",
            "body": "This sounds more complicated than it really needs to be.\n\nFirst, you only need to configure `logging` _once_; usually you'd do this in the main script, and the other files would simply use\n\n    import logging\n\n    logger = logging.getLogger(__file__)\n\nso there's no need to create your own function you import everywhere. That's needless complexity, and may in fact be the source of some of your problems.\n\nSecond, `logging` already has built-in support for rotating file handlers (in fact you have a few options there), so unless you _really_ need a custom solution I'd strongly recommend you use those instead, simplifying things further.\n\nAs an example, [here's what I do in my personal projects](https://github.com/Diapolo10/python-poetry-template/blob/main/src/project_name/logger.py). It's not perfect, for example I'm still not satisfied with the type annotations, but it works well enough.",
            "score": 1,
            "replies": [
                {
                    "author": "GoatRocketeer",
                    "body": "I see.\n\nAfter reading your comment, I went back and looked at why I was using per-module configuration. I did not know what logger configuration inheritance was (basically ran into exactly the same thing this guy did [https://stackoverflow.com/a/50755200](https://stackoverflow.com/a/50755200) )\n\nThat plus the \"module\" log record attribute and I now have a single fileHandler and which lets me rotate my files without issue.\n\nThank you.",
                    "score": 1,
                    "replies": []
                }
            ]
        }
    ]
}